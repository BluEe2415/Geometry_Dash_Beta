<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Mini Geometry Dash</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: #222;
    width: 100%;
    height: 100%;
    font-family: Arial, sans-serif;
  }
  canvas {
    display: block;
  }
  #restartButton {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 20px 40px;
    font-size: 24px;
    border: none;
    border-radius: 10px;
    cursor: pointer;
    display: none;
  }
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>
<button id="restartButton">Restart</button>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const restartButton = document.getElementById("restartButton");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player, spikes, score, gameOver, obstacleTimer;
const speed = 8;

function initGame() {
  player = {
    x: 60,
    y: canvas.height - 70,
    size: 60,
    dy: 0,
    gravity: 1,
    jumpPower: -20,
    onGround: true
  };

  spikes = [];
  score = 0;
  gameOver = false;
  obstacleTimer = 0;
  restartButton.style.display = "none";
}

function spawnSpike() {
  const height = Math.random() * 50 + 40; // verschiedene Höhen
  spikes.push({
    x: canvas.width,
    width: height,   // Breite passt sich der Höhe an
    height: height
  });
}

function drawSpike(spike) {
  const baseY = canvas.height;

  ctx.fillStyle = "#ff4444";
  ctx.beginPath();
  ctx.moveTo(spike.x, baseY);
  ctx.lineTo(spike.x + spike.width / 2, baseY - spike.height);
  ctx.lineTo(spike.x + spike.width, baseY);
  ctx.closePath();
  ctx.fill();
}

function update() {
  if (gameOver) return;

  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Player physics
  player.dy += player.gravity;
  player.y += player.dy;

  if (player.y + player.size >= canvas.height) {
    player.y = canvas.height - player.size;
    player.dy = 0;
    player.onGround = true;
  }

  // Spikes
  obstacleTimer++;
  if (obstacleTimer > 90) {
    spawnSpike();
    obstacleTimer = 0;
  }

  for (let i = spikes.length - 1; i >= 0; i--) {
    const s = spikes[i];
    s.x -= speed;

    if (s.x + s.width < 0) {
      spikes.splice(i, 1);
      score++;
      continue;
    }

    // Collision
    if (
      player.x < s.x + s.width &&
      player.x + player.size > s.x &&
      player.y + player.size > canvas.height - s.height
    ) {
      gameOver = true;
      restartButton.style.display = "block";
    }

    drawSpike(s);
  }

  // Player
  ctx.fillStyle = "white";
  ctx.fillRect(player.x, player.y, player.size, player.size);
  ctx.fillStyle = "black";
  ctx.font = "32px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("67", player.x + player.size / 2, player.y + player.size / 2);

  // Score oben Mitte
  ctx.fillStyle = "white";
  ctx.font = "30px Arial";
  ctx.fillText("Score: " + score, canvas.width / 2, 50);

  requestAnimationFrame(update);
}

// Jump
function jump() {
  if (player.onGround && !gameOver) {
    player.dy = player.jumpPower;
    player.onGround = false;
  }
}

document.addEventListener("mousedown", jump);
document.addEventListener("touchstart", jump);

// Restart
restartButton.addEventListener("click", () => {
  initGame();
  update();
});

// Resize
window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

initGame();
update();
</script>
</body>
</html>
